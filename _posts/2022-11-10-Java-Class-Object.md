---
layout: post
title:  " 클래스와 객체 "
categories: Java
author: fancy96
---
* content
{:toc}

## 객체 지향과 자바

### 자바의 객체 지향 특성

* 캡슐화(encapsulation)
  
  * 캡슐화는 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 하는 것으로 객체의 가장 본질적인 특징이다.
  
  * 객체는 캡슐화가 기본 원칙이지만 외부와의 접속을 위해 몇 부분만 공개 노출한다. (on/off 버튼)
    
  * 자바에서 클래스(class) 는 객체의 모양을 선언한 틀이며, 클래스 모양 그대로 생성된 실체(instance)가 `객체` 이다.
    
  * 자바는 필드(field)와 메소드(method)를 클래스 내에 모두 구현한다.

  ![](/assets/img/java/Java_Class_Object_1.png)

* 상속(inheritancd)

  * 상속은 상위 객체의 속성이 하위 객체에 물려져서, 하위가 상위 개체의 속성을 모두 가지는 관계이다.
  
  * 자바의 상속은 자식 클래스가 부모 클래스의 속성을 물려받아 부모 클래스에 기능을 `확장(extends)`하는 개념이다.
  
  * 자바에서 부모 클래스를 `슈퍼 클래스(super class)`라고 부르며 자식 클래스를 `서브 클래스(sub class)`라고 부른다.
  
  * 상속은 슈퍼 클래스에 만들어진 필드와 메소드를 물려받음으로써 코드의 중복 작성을 방지하고, 코드를 재사용함으로써 코드 작성에 드는 시간과 비용을 줄인다.

  ![](/assets/img/java/Java_Class_Object_2.png)

* 다형성(polymorphsm)

  * 다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것을 말한다.

  ![](/assets/img/java/Java_Class_Object_3.png)

  * 이것은 슈퍼 클래스에서 구현된 메소드를, 서브 클래스에서 자신의 특징에 맞게 동일한 이름으로 다시 구현하는 이른바 `메소드 오버라이딩(overriding)`으로 부른다.

---

### 객체 지향 언어의 목적

* 소프트웨어의 생산성 향상

* 실세계에 대한 쉬운 모델링

### 절차 지향 프로그래밍과 객체 지향 프로그래밍

* 절차 지향 프로그래밍은 목적을 달성하기 위한 일의 흐름에 중점을 둔다.

* 객체 지향 프로그래밍은 실세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 나타낸다.

![](/assets/img/java/Java_Class_Object_4.png)

### 클래스와 객체

* 클래스는 객체를 만들어 내기 위한 설계 혹은 틀이며, 클래스에 선언된 모양 그대로 생성된 실체가 `객체`이다.

* 객체를 클래스의 `인스턴스(instance)`라고도 부르며, 가끔 객체와 인스턴스는 구별 없이 사용한다.

---

## 자바 클래스 만들기

### 객체 생성과 활용

1. 레퍼런스 변수 선언

* 객체를 생성하기 전 객체를 가리킬 레퍼런스 변수의 선언이 필요하다.

``` java
Circle pizza; // 래퍼런스 변수 pizza 선언
```

* 이 선언문으로 Circle 객체가 생성되지 않는다. 변수 pizza는 Circle 타입의 객체를 가리키는 레퍼런스 변수일 뿐 객체 자체는 아니다. 레퍼런스 변수를 **객체 이름**이라고도 부른다.

2. new 연산자로 객체 생성

* 자바에서는 반드시 new 연산자를 사용하여 다음과 같이 객체를 생성한다.

``` java
	pizza = new Circle(); // Circle 객체 생성
```

* new 연산자는 Circle 타입의 크기만한 메모리를 할당받아 메모리에 대한 레퍼런스(주소)를 리턴한다. 레퍼런스(주소) 값은 변수 pizza에 대입된다.

* 레퍼런스 변수를 선언하면서 다음과 같이 동시에 객체를 생성하기도 한다.

``` java
Circle pizza = new Circle() // 레퍼런스 변수 pizza의 선언과 동시에 객체 생성
```

3. 객체 맴버 접근

* 객체의 멤버에 접근할 때는 다음과 같이 `점(.) 연산자`를 이용한다.

* `객체레퍼런스.멤버`

---

## 생성자

### 생성자의 개념과 목적

* 생성자는 객체가 생성될 때 초기화를 위해 실행되는 메소드이다.

### 생성자의 작성 및 활용

* 생성자는 객체가 생성되는 순간에 자동으로 호출되는 메소드로서, 객체에 필요한 초기화를 수행하는 코드이다.

* 다음 예제는 Circle 클래스에 2개의 생성자를 축하여 수정한 코드를 보여준다.

``` java
public class Circle {
	int radius;
	String name;
	
	public Circle() { // 매개 변수 없는 생성자
		radius = 1; name = ""; // radius의 초기값은 1
	}
	
	public Circle(int r, String n) { // 매개 변수를 가진 생성자
		radius = r; name = n;	// 생성자는 radius와 name 필드 초기화
	}
	
	public double getArea() {
		return 3.14*radius*radius;
	}
	
	public static void main(String[] args) {
		Circle pizza = new Circle(10, "자바피자");	// Circle 객체 생성, 반지름 10
		double area = pizza.getArea();
		System.out.println(pizza.name + "의 면적은 " + area);
		
		Circle donut = new Circle(); // Circle 객체 생성, 반지름 1
		donut.name = "도넛피자";
		area = donut.getArea();
		System.out.println(pizza.name + "의 면적은 " + area);
	}
}
```

### 생성자의 특징

* 생성자의 이름은 클래스 이름과 동일하다. 

* 생성자를 여러 개 작성할 수 있다.

``` java
public class Circle {
	public Circle() {...} // 매개 변수 없는 생성자
	public Circle(int r, String n) {...} // 2개의 매개 변수를 가진 생성자
}
```

* 생성자는 객체를 생성할 때 **한 번만** 호출된다.

``` java
Circle pizza = new Circle(10, "자바피자"); // 생성자(Citcle(int r, String n) 호출
Circle donut = new Circle()' // 생성자 Circle() 호출
```

* 생성자에 **리턴 타입을 지정할 수 없다.**

  * 리턴할 값이 없다고 해서 void를 리턴 타입으로 지정해서도 안 된다.

``` java
public void Circle() {...} // 오류(void)
```

* 생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.

  * new의 객체 생성 문은 Circle(int r, String n) 생성자를 호출하여, pizza 객체의 radius 필드를 10으로, name 필드를 “자바피자”로 초기화한다.

``` java
	Circle pizza = new Circle(10, "자바피자"); // 생성자 Circle(int r, String n) 호출
```

### 기본 생성자

* 기본 생성자(default constructor)란 매개 변수가 없고 또한 실행 코드가 없어 아무일도 하지 않고 단순 리턴하는 생성자이다.(= 디폴드 생성자)

* 기본 생성자가 자동으로 생성되는 경우

  * 클래스에 **생성자가 하나도 선언되지 않은 경우**, 컴파일러는 기본 생성자를 자동으로 생성한다.

* 기본 생성자가 자동으로 생성되지 않은 경우
  
  * 생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본 생성자를 임의로 삽입해 주지 않는다.

### this 레퍼런스

* this는 **객체 자신에 대한 레퍼런스**로서 메소드 안에서 사용된다.

* this는 컴파일러에 의해 자동으로 관리되므로, 개발자는 사용하기만 하면 된다.

``` java
class Circle {
	int radius;
	public Circle() { this.radius = 1; }
	public Cicle(int radius) { this.radius = radius; }
	public double getArea() { return 3.14 * this.radius * this.radius; }
```

### this()로 다른 생성자 호출

* this()는 클래스 내에서 생성자가 **다른 생성자를 호출**할 때 사용하는 자바 코드이다.

* this() 사용 시에 몇 가지 주의할 사항이 있다.

  * this()는 **생성자**에서만 사용된다.

  * this()는 반드시 **같은 클래스의 다른 생성자를 호출**할 때 사용된다.

  * this()는 반드시 **생성자의 첫 번째 문장**으로 사용되어야 한다.

---

## 객체 배열

### 객체 배열

* 자바에서 객체를 원소로 하는 배열을  만들 수 있다.

* 자바의 객체 배열은 객체에 대한 **레퍼런스를 원소로 갖는 배열**이다.

``` java
Circle [] c = new Circle[5]; // 배열에 대한 레퍼런스 선언 및 레퍼런스 배열 생성

for(int i = 0; i , c.length; i++) // c.lengh는 배열 c의 크기로서 5
	c[i] = new Circle(i); // i 번째 Circle 객체 생성
```

* 배열의 크기만큼 Cicle 객체를 생성하며 레퍼런스 배열에 하나씩 대입한다.

### 배열의 원소 객체 접근

* 배열 c의 i번째 객체를 접근하기 위해서는 c[i] 레퍼런스를 사용한다.

* 다음 코드는 배열 c에 들어 있는 모든 Circle 객체의 면적을 출력한다.

``` java
for(int i = 0; i < c.length; i++)
	System.out.print((int)(c[i].getArea()) + " ");
```

![](/assets/img/java/Java_Class_Object_5.png)

---

## 메소드 활용과 객체 치환

* 이 절은 메소드의 형식과, 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 `메소드 오버로딩`에 대한 설명이다.

### 메소드 형식

* 자바의 메소드는 클래스의 멤버 함수로서 접근 지정자를 선언한다는 점 외에 C/C++ 함수의 작성법과 동일하다.

``` java
public int getSum(int i, int j) {
		int sum;
		sum = i + j;
		return sum;
}
```

* public: 접근 지정자

* int: 리턴 타입

* getSum: 메소드 이름

* (int i, int j): 메소드 인자들

* int sum ~ return sum: 메소드 코드

### 인자 전달

* 기본 타입이 전달되는 경우 ⇒ **값이 변경되지 않음**

  * 매개 변수가 byte, char, int, double 등 기본 타입으로 선언되는 경우 호출자(caller)가 건네는 값이 메소드의 매개 변수에 복사되어 전달된다.
  
  * 하지만, 기존 변수의 값을 바꾸지는 못한다.

* 객체가 전달되는 경우 ⇒ **값이 변경됨**
  
  * 메소드의 매개변수가 클래스 타입인 경우, 객체가 아니라 **객체의 레퍼런스 값**이 전달된다.
  
  * 기존 변수의 값을 바꾼다.
  
  * 하지만, 메소드 호출 시 객체가 전달되는 경우, 객체에 대한 레퍼런스만 전달되지 객체가 통째로 복사되지는 않는다.

* 배열이 전달되는 경우
  
  * 배열이 전달 되는 경우도 객체가 전달되는 경우와 동일하게, 배열이 통째로 전달되는 것이 아니라, **배열에 대한 레퍼런스만 전달**된다.

### 메소드 오버로딩

* 자바에서는 클래스 내에 이름은 같지만 매개 변수의 타입이나 개수가 서로 다른 여러개의 메소드를 작성할 수 있다. 이것을 `메소드 오버로딩`(method overloading) 혹은 **메소드 중복**이라고 부른다.

* 메소드 오버로딩은 `다형성`의 한 종류이다.

* 메소드 오버로딩이 성립되려면 다음 두 조건을 만족하여야 한다.
  
  * 메소드 이름이 동일하여야 한다.
  
  * 메소드 매개 변수의 개수나 타입이 서로 달라야 한다.

---

## 객체의 소멸과 가비지 컬렉션

* 자바에서는 객체를 생성하는 new 연산자는 있지만 **객체를 소멸하는 연산자는 없다.**

* 자바에서는 응용프로그램에서 사용하지 않고 있는 객체나 배열 메모리를 자바 가상 기계가 알아서 수거해가기 때문에, 사용하지 않는 메모리를 되돌려 주어야하는 코딩 책임으로부터 개발자를 해방시켜 코딩의 부담을 대폭 줄여 준다.

### 가비지(garbage)

* 할당받는 객체나 배열 메모리 중에서 더 이상 사용하지 않게 된 메모리를 `가비지garbage)`라고 부른다.

* 자바 플랫폼은 **참조하는 레퍼런스가 하나도 없는 객체나 배열**을 가비지로 판단한다.

### 가비지 컬렉션(garbage collection)

* 가비지가 많아지면 응용프로그램에서 할당해줄 수 있는 `가용 메모리`의 양이 줄어든다.

* 가용 메모리가 0이 되면 자바 응용프로그램은 더이상 실행될 수 없게 된다.

* 가용 메모리 공간이 일정 크기 이하로 줄어들면, 자바 가상 기계는 자동으로 가비지를 회수하여 가용 메모리 공간을 늘린다. 이것을 `가비지 컬렉션`이라고 부른다.

* 가비지 컬렉션은 자바 가상 기계 내에 준비된 `가비지 컬렉션 스레드`에 의해 처리된다.

---

## 접근 지정자

### 자바의 패키지 개념

* 자바에서는 상호 관련 있는 클래스 파일들을 `패키지(pakage)`에 저장하여 관리한다.

* 패키지는 `디렉터리` 혹은 폴더와 같은 개념이다.

### 접근 지정자

* 대부분의 객체 지향 언어는 접근 지정자(access specifier)를 두고 있다.

* 접근 지정자는 클래스나 멤버들을 다른 클래스에 접근해도 되는지의 여부를 선언하는 지시어이다.

  * private, protected, public

![](/assets/img/java/Java_Class_Object_6.png)

---

## static 멤버

### static 멤버의 특성

* static 멤버는 클래스당 하나만 생성되는 멤버로서, 동일한 클래스의 모든 객체들이 공유하므로 `클래스 멤버`라고 부른다.

* non-static 멤버는 각 객체마다 별도로 생기므로 `인스턴스 멤버`라고 부른다.

* static 멤버의 차이와 non-static 멤버 의 차이

![](/assets/img/java/Java_Class_Object_7.png)


* static의 활용

  * 전역 변수와 전역 함수를 만들 때 활용

  * 공유 멤버를 만들고자 할 때 활용

* static 메소드의 제약 조건

  * static 메소드는 오직 static 멤버만 접근할 수 있다.

  * static 메소드에서는 this를 사용할 수 없다.

---

## final

* final 키워드는 3가지 용도로 사용된다.

### final 클래스

* final이 클래스 이름 앞에 사용되면 **클래스를 상속받을 수 없음**을 지정한다.

### final 메소드

* 메소드 앞에 final이 붙으면 이 **메소드는 더 이상 오버라이딩할 수 없음**을 지정한다.

### final 필드

* 자바에서는 final로 필드를 선언하면 필드는 **상수**가 된다.

## Reference

* 책 - [명품 자바 에센셜](http://www.yes24.com/Product/Goods/63041975)