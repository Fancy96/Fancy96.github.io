---
layout: post
title:  " TCP와 UDP "
categories: Network
author: devfancy
---
* content
{:toc}

## 전송 계층

* 전송 계층은 **인터넷 기반의 송신자와 수신자를 연결**하는 통신 서비스를 제공하며 

    [1]연결 지향 데이터 스트림 지원, [2]신뢰성, [3]흐름 제어를 제공할 수 있으며 

    애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때 **중계 역할**을 한다.

* 대표적으로 TCP와 UDP가 있다.

## TCP/UDP 계층의 기능 및 역할

* **실제 데이터의 송신과 관련 있는 계층**으로 전송(Transport) 계층이라고도 한다.

### TCP

* `TCP`(Transmission Control Protocol)는 데이터의 전송을 보장하는 프로토콜이다.(**신뢰성**이 있는 프로토콜)

* TCP는 패킷 사이의 순서를 보장하고 신뢰성을 보장하기 때문에 **연결 지향 프로토콜**로 수신여부를 확인하기 때문에 **신뢰성은 높지만 속도가 느리다는 단점**이 있다.

* 대부분 1대1 통신이며, **가상 회선 패킷 교환방식**을 사용한다. 

    * 가상 회선 패킷 교환방식 - 각 패킷에는 가상회선 식별자가 포함되며, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 **순서대로** 도착하는 방식을 말한다.

    ![](/assets/img/network/network-tcp-and-udp-1.jpg)

* 예) HTTP, Email, File transfer

### UDP

* `UDP`(User Datagram Protocol)는 데이터의 전송을 보장하지 않는 프로토콜이다.

* UDP는 패킷 사이의 **순서를 보장하지 않고 수신 여부를 확인하지 않으며** 단순히 데이터만 주는 `데이터 패킷 교환 방식`을 사용한다.

    * 데이터 패킷 교환 방식 - 패킷이 독립적으로 이동하며 최적의 경로를 선택하여 간다. 하나의 메시지에서 분할된 여러 패킷은 도착한 **순서가 다를 수** 있는 방식을 말한다.

    ![](/assets/img/network/network-tcp-and-udp-2.jpg)

* 1대1 통신 또는 1대 N 통신 또는 N:N 통신이 있다.

* 예) DNS, Broadcasting

## 흐름 제어 기법(Flow control)

* 송신측과 수신측의 **데이터 처리 속도 차이를 해결** 하기 위한 방법

1. 정지-대기(Stop-and-wait) 기법

2. 슬라이딩 윈도우 (Sliding Window) 기법

### Stop-and wait 동작 방법

* 전송 측이 프레임을 전송한 다음, 각 데이터 프레임에 대한 `ACK`를 기다린다.

* `ACK` 프레임이 도착하면 다음 프레임을 전송하는 기법이다.

![](/assets/img/network/network-tcp-and-udp-3.png)

### Sliding Window 동작 방법

* 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있어서 **데이터 흐름을 동적으로 조절**하는 기법이다.

  * Window : 전송 및 수신 측에서 만들어진 **버퍼의 크기**

* ACK 프레임이 도착하면, 전송측 윈도우는 ACK 프레임 수에 따라 오른쪽 경계가 이동하여 윈도우 크기가 늘어난다.

![](/assets/img/network/network-tcp-and-udp-4.png)

## TCP의 내부동작 원리1: 연결 설정 단계

> 상황 : 팬시가 주디에게 데이터를 전달하는 상황

* 팬시 : 안녕! 주디, 내가 전달할 데이터가 있으니 우리 연결좀 하자.

* 주디 : 알겠어! 지금 나도 준비가 되었으니 언제든 시작해도 좋아!

* 팬시 : 내 요청을 들어줘서 고마워~

이런 TCP 연결 성립 과정을 `Three-way handshaking` 이라고 한다.

**SYN** - SYN + ACK - **ACK**

![](/assets/img/network/network-tcp-and-udp-5.png)

* 처음 시작 SEQ번호는 **랜덤하게 생성**된다. 그 이유는 연결을 맺을 때 사용하는 포트(Port)는 **유한 범위 내에서 사용하고 시간이 지남에 따라 재사용**된다.

* 따라서 두 통신 호스트가 **과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재**한다. 서버측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 숫자가 전송된다면 **이전의 연결로부터 오는 패킷으로 인식**할 수 있다. 

* 이런 문제의 발생 가능성을 낮추기 위해 SEQ번호를 랜덤으로 설정한다.

## TCP의 내부동작 원리2: 상대 소켓과의 데이터 송수신

![](/assets/img/network/network-tcp-and-udp-6.png)

* ACK의 값을 전송된 바이트 크기만큼 증가시키는 이유는 **패킷의 전송유무 뿐만 아니라, 데이터 손실유무까지 확인**하기 때문이다.

  * [1] ACK = 1200 + 100 byte + 1

  * [2] ACK = 1301 + 100 byte + 1

* ACK 번호 = **SEQ 번호 + 전송된 바이트 수 + 1**

* SEQ 전송 시 타이머가 작동되며 SEQ에 대한 ACK가 전송되지 않을 경우 데이터를 재전송한다.

## TCP의 내부동작 원리3: 상대 소켓과의 연결종료

> 상황 : 팬시가 주디에게 연결을 끊고자 하는 경우

* 팬시 : 주디! 지금 연결을 끊고자 하는데 지금 괜찮을까요?

* 주디 : 아! 그러세요? 잠시만요~

* 주디 : 네 저도 준비가 끝났습니다. 그럼 연결을 끊으시죠!

* 팬시 : 네! 그동안 즐거웠습니다.

이러한 TCP 연결 해제 과정을 `Four-way handshaking` 이라고 한다. 

**FIN** – ACK – FIN - **ACK**

![](/assets/img/network/network-tcp-and-udp-7.png)

* TCP의 연결 성립 과정과 연결 해제 과정의 **단계수가 차이 나는 이유**는 클라이언트가 데이터 전송을 마쳤다고 해도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후 자신(서버)도 FIN 메시지를 보내기 때문이다.

* 그래서 마지막 4번째인 클라이언트(팬시)에서 **TIME_WAIT** 상태가 된다. 서버(주디)로부터 해지 준비가 되었다는 ACK를 보낸후 서버에서 CLOSE 상태가 된 이후에 클라이언트(팬시)는 어느 정도의 시간을 대기한 후에 연결을 닫고 모든 자원의 연결이 종료된다.

* `TIME_WAIT`이란 소켓이 바로 소멸되지 않고 일정 시간 유지하는 상태이다.

* `Four-way handshaking` 과정을 거쳐서 연결을 종료하는 이유는 **패킷이 지연되거나 일반적인 종료로 인한 데이터 손실을 막기 위함**이다.


## 예상 질문

* Q1. TCP와 UDP의 차이점은?

* Q2. 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는?

  * A2. 그 이유는 연결을 맺을 때 사용하는 포트(Port)는 **유한 범위 내에서 사용하고 시간이 지남에 따라 재사용**된다. 따라서 두 통신 호스트가 **과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재**한다. 서버측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 숫자가 전송된다면 **이전의 연결로부터 오는 패킷으로 인식**할 수 있다. 이런 문제의 발생 가능성을 낮추기 위해 SEQ번호를 랜덤으로 설정한다.


* Q3. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

  * A3. 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정시간(Default: 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)


* Q4. TCP의 연결 성립 과정과 연결 해제 과정의 단계수가 차이 나는 이유는?

  * A4. Client가 데이터 전송을 마쳤다고 해도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후 자신도 FIN메세지를 보내기 때문이다.



## Reference

* 학교 수업 자료 - 컴퓨터망프로그래밍

* [면접을 위한 CS 전공 지식 노트](https://product.kyobobook.co.kr/detail/S000001834833)

* [2023-CS-Study : TCP/IP 4계층 모델](https://github.com/devfancy/2023-CS-Study/blob/main/Network/network_tcp_and_udp.md)