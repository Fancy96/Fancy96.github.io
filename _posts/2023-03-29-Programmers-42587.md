---
layout: post
title: " [Programmers] 42587. 프린터 "
categories: Algorithm
author: fancy96
---
* content
{:toc}

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42587`)

## 성능 요약

* 메모리: 78.4 MB, 시간: 0.68 ms

## 구분

* 코딩테스트 연습 > 스택／큐

## Answer Code1(23.03.29)

```java
import java.util.*;
class Solution {
    public int solution(int[] priorities, int location) {
        Queue<Pair> queue = new LinkedList<>();
        int answer = 0;

        for(int i = 0; i < priorities.length; i++) {
            queue.add(new Pair(i, priorities[i]));
        }

        while(!queue.isEmpty()) {
            int current = queue.peek().value;

            boolean flag = false;

            for(Pair pair : queue) {
                if(pair.value > current) {
                    flag = true;
                    break;
                }
            }

            if (flag) { //우선순위가 높은게 있으면 뒤로 보낸다.
                Pair temp = queue.poll();
                queue.add(temp);
            } else {
                answer++;
                Pair pair = queue.poll();

                if(pair.index == location) {
                    return answer;
                }
            }
        }

        return answer;
    }
    class Pair {
        int index;
        int value;

        public Pair(int index, int value) {
            this.index = index;
            this.value = value;
        }
    }
}
```

## Answer Code2(23.03.29)

```java
import java.util.*;

class Solution {
    public int solution(int[] priorities, int location) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        int answer = 0;
        
        for (int i = 0; i < priorities.length; i++) {
            pq.add(priorities[i]);
        }
        
        while (!pq.isEmpty()) {
            for (int i = 0; i < priorities.length; i++) {
                if (priorities[i] == pq.peek()) {
                    if (i == location) {
                        answer++;
                        return answer;
                    }
                    pq.poll();
                    answer++;
                }
            }
        }
        return -1;
    }
}
```

## Review

* 1번은 그냥 큐로 구현한 것이고, 2번은 우선순위 큐로 구현한 것이다.

* 문제에 대한 설명을 읽고 직관적으로 큐를 사용해서 구현해야 했다.

* 큐에 남아있는 값들 중 방금 뽑은 값보다 더 높은 우선순위가 있으면 다시 큐에 넣는 식으로 했다.

## Reference

* [알고리즘 - 프린터](https://easybrother0103.tistory.com/112)