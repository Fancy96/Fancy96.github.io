---
layout: post
title:  " [내 코드가 그렇게 이상한가요?] 13 - 16장 정리 "
categories: GoodCode
author: devFancy
---
* content
{:toc}

## 13장. 모델링: 클래스 설계의 토대

### 시스템, 모델, 모델링

* 시스템

    * 사전 정의: 수많은 구성 요소로 이루어진 집합체로, 각각의 부분이 유기적으로 연결되어, 전체적으로 하나의 목적을 갖고 움직이는 것

    * 시스템은 목적 달성을 위한 수단

* 모델: 특정 목적 달성을 위해서, **최소한으로 필요한 요소를 갖춘 것**

* 모델링: 모델의 의도를 정의하고, 구조를 설계하는 것

### 모델링

* 모델은 대상이 아니라 **목적 달성의 수단**이다.

    * `목적` 중심으로 이름을 잘 설계하면, 목적을 달성하기에 적절한 모델을 설계할 수 있다.

* 단일 책임 원칙 == 단일 목적 원칙

    * **특정 목적에 특화되게 설계해야, 변경하기 쉬운 고품질 구조**를 갖게 된다.

* 모델을 검토할 때 목적 이외에 요소가 들어가 있다면 다시 수정한다.

* 모델 != 클래스 => 모델 하나는 여러 개의 클래스로 구성된다. (1:N)

    * 예를 들어, 모델 - 상품이면, 클래스 - 상품 ID, 상품명, 판매 가격, 재고 수량 

    * 클래스 설계와 구현에서 무언가를 깨닫는다면, 이를 모델에 피드백해야 한다.

    * **피드백 사이클을 계속 돌리는 것**이 설계 품질을 높이는 비결이다.

### 기능성과 모델링의 관계

* `기능성`은 소프트웨어의 품질 특성 중 하나로, **고객의 니즈를 만족하는 정도**를 말한다.

* 숨어있는 목적 파악하기

    * 상품 구매를 하면, '상품 구입'과 '구매 품목'에 대해서만 생각할 수 있지만, 법적인 요소도 고려해야 한다.

    * 위처럼 기능을 제대로 발휘하려면, **'개념의 정체'와 '뒤에 숨어 있는 중요한 목적'을 잘 파악**해야 한다.

    * `목적 달성` 수단으로 해석하면, 추상화 했을 때 **모델의 확장성이 커진다.**

    * 예를 들어, `이동 수단`이라는 목적을 추상화 했다면, 구체화로는 이족 보행, 마차, 전차, 전기 자동차, 비행기가 있다.

## 14장. 리팩터링

* `리팩터링`이란 **실질적인 동작은 유지하면서, 구조만 정리하는 작업**이다.

### 리팩터링의 흐름

* 중첩을 제거하여 보기 좋게 만든다.

* 의미 단위로 로직을 정리한다. -> 조건 확인과 값 대입 로직을 각각 분리해서 정리한다.

* 조건을 읽기 쉽게 한다. -> 논리 부정 연산자 `!`를 사용하는 것처럼 한번 더 생각하게 되는 요소가 있으면 **메서드로 추출**해서 읽기 쉽게 한다.

* 목적을 나타내는 메서드로 만들어서 사용한다. -> 보유 포인트가 부족한지 리턴하는 메서드 = `isShotOfPoint`

### 실수 줄이는 방법: 단위 테스트

* `단위 테스트`는 작은 기능 단위로 동작을 검증하는 테스트를 의미하며, 일반적으로 '테스트 프레임워크와 테스트 코드를 활용해서 메서드 단위로 동작을 검증하는 방법'이라 한다.

    * (참고로, 이 책에서는 테스트 프레임워크로는 `JUnit`을 사용한다)

* '리팩터링을 할 때 단위 테스트는 필수다!'라는 말이 있을 정도로 **`리팩터링`과 `단위 테스트`는 항상 세트**이다.

> 테스트 코드를 사용한 리팩터링 흐름

1. 이상적인 구조의 클래스 기본 형태를 어느 정도 잡는다.

2. 이 기본 형태를 기반으로 테스트 코드를 작성한다.

3. 테스트를 실패시킨다.

4. 테스트를 성공시키기 위한 최소한의 코드를 작성한다.

5. 테스트가 성공할 수 있도록, 조금씩 로직을 이상적인 구조로 리팩터링한다.

### 리팩터링 시 주의 사항

* 기능 추가와 리팩터링을 동시에 하지 않는다.

    작업을 할 때는 '기능 추가(adding function)'와 '리팩터링(refactoring)' 중에서 하나만 쓰고 있어야 한다. - 리팩터링 2판, 17.1.3절 - 

    리포지토리에 커밋할 때 기능 추가와 리팩터링을 따로 구분해야 한다.

* 작은 단계(small step)로 실시하는 것이 좋다.

    리팩터링으로 메서드 이름 변경과 로직 이동을 했다면, 커밋을 따로따로 구분하는 것이 좋다. -> 커밋1: 메서드 이름 변경, 커밋2: 로직 이동

    여러 번 커밋했다면, `풀 리퀘스트(Pull Request)` 를 작성하는 것이 좋다.

* 리팩터링 시 언어와 프레임워크의 특성을 고려한 설계와 적용 방법을 생각해 보는 것이 중요하다.

## 15장. 설계의 의의와 설계를 대하는 방법



## 16장. 설계를 방해하는 개발 프로세스와의 싸움