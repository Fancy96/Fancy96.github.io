---
layout: post
title:  " [내 코드가 그렇게 이상한가요?] 13 - 16장 정리 "
categories: GoodCode
author: devFancy
---
* content
{:toc}

> 이 글은 [내 코드가 그렇게 이상한가요?](https://product.kyobobook.co.kr/detail/S000202521361) 책을 읽고 정리한 내용을 바탕으로 작성하였습니다.

## 13장. 모델링: 클래스 설계의 토대

### 시스템, 모델, 모델링

* 시스템

    * 사전 정의: 수많은 구성 요소로 이루어진 집합체로, 각각의 부분이 유기적으로 연결되어, 전체적으로 하나의 목적을 갖고 움직이는 것

    * 시스템은 목적 달성을 위한 수단

* 모델: 특정 목적 달성을 위해서, **최소한으로 필요한 요소를 갖춘 것**

* 모델링: 모델의 의도를 정의하고, 구조를 설계하는 것

### 모델링

* 모델은 대상이 아니라 **목적 달성의 수단**이다.

    * `목적` 중심으로 이름을 잘 설계하면, 목적을 달성하기에 적절한 모델을 설계할 수 있다.

* 단일 책임 원칙 == 단일 목적 원칙

    * **특정 목적에 특화되게 설계해야, 변경하기 쉬운 고품질 구조**를 갖게 된다.

* 모델을 검토할 때 목적 이외에 요소가 들어가 있다면 다시 수정한다.

* 모델 != 클래스 => 모델 하나는 여러 개의 클래스로 구성된다. (1:N)

    * 예를 들어, 모델 - 상품이면, 클래스 - 상품 ID, 상품명, 판매 가격, 재고 수량 

    * 클래스 설계와 구현에서 무언가를 깨닫는다면, 이를 모델에 피드백해야 한다.

    * **피드백 사이클을 계속 돌리는 것**이 설계 품질을 높이는 비결이다.

### 기능성과 모델링의 관계

* `기능성`은 소프트웨어의 품질 특성 중 하나로, **고객의 니즈를 만족하는 정도**를 말한다.

* 숨어있는 목적 파악하기

    * 상품 구매를 하면, '상품 구입'과 '구매 품목'에 대해서만 생각할 수 있지만, 법적인 요소도 고려해야 한다.

    * 위처럼 기능을 제대로 발휘하려면, **'개념의 정체'와 '뒤에 숨어 있는 중요한 목적'을 잘 파악**해야 한다.

    * `목적 달성` 수단으로 해석하면, 추상화 했을 때 **모델의 확장성이 커진다.**

    * 예를 들어, `이동 수단`이라는 목적을 추상화 했다면, 구체화로는 이족 보행, 마차, 전차, 전기 자동차, 비행기가 있다.

## 14장. 리팩터링

* `리팩터링`이란 **실질적인 동작은 유지하면서, 구조만 정리하는 작업**이다.

### 리팩터링의 흐름

* 중첩을 제거하여 보기 좋게 만든다.

* 의미 단위로 로직을 정리한다. -> 조건 확인과 값 대입 로직을 각각 분리해서 정리한다.

* 조건을 읽기 쉽게 한다. -> 논리 부정 연산자 `!`를 사용하는 것처럼 한번 더 생각하게 되는 요소가 있으면 **메서드로 추출**해서 읽기 쉽게 한다.

* 목적을 나타내는 메서드로 만들어서 사용한다. -> 보유 포인트가 부족한지 리턴하는 메서드 = `isShotOfPoint`

### 실수 줄이는 방법: 단위 테스트

* `단위 테스트`는 작은 기능 단위로 동작을 검증하는 테스트를 의미하며, 일반적으로 '테스트 프레임워크와 테스트 코드를 활용해서 메서드 단위로 동작을 검증하는 방법'이라 한다.

    * (참고로, 이 책에서는 테스트 프레임워크로는 `JUnit`을 사용한다)

* '리팩터링을 할 때 단위 테스트는 필수다!'라는 말이 있을 정도로 **`리팩터링`과 `단위 테스트`는 항상 세트**이다.

> 테스트 코드를 사용한 리팩터링 흐름

1. 이상적인 구조의 클래스 기본 형태를 어느 정도 잡는다.

2. 이 기본 형태를 기반으로 테스트 코드를 작성한다.

3. 테스트를 실패시킨다.

4. 테스트를 성공시키기 위한 최소한의 코드를 작성한다.

5. 테스트가 성공할 수 있도록, 조금씩 로직을 이상적인 구조로 리팩터링한다.

### 리팩터링 시 주의 사항

* 기능 추가와 리팩터링을 동시에 하지 않는다.

    작업을 할 때는 '기능 추가(adding function)'와 '리팩터링(refactoring)' 중에서 하나만 쓰고 있어야 한다. - 리팩터링 2판, 17.1.3절 - 

    리포지토리에 커밋할 때 기능 추가와 리팩터링을 따로 구분해야 한다.

* 작은 단계(small step)로 실시하는 것이 좋다.

    리팩터링으로 메서드 이름 변경과 로직 이동을 했다면, 커밋을 따로따로 구분하는 것이 좋다. -> 커밋1: 메서드 이름 변경, 커밋2: 로직 이동

    여러 번 커밋했다면, `풀 리퀘스트(Pull Request)` 를 작성하는 것이 좋다.

* 리팩터링 시 언어와 프레임워크의 특성을 고려한 설계와 적용 방법을 생각해 보는 것이 중요하다.

## 15장. 설계의 의의와 설계를 대하는 방법

### 어떤 설계를 주제로 집필했는가 : 유지 보수성

* 소프트웨어의 제품과 관련된 품질 특성은 다음과 같다.

    * 기능 적합성, 성능 효율성, 호환성, 사용성, 신뢰성, 보안, 유지 보수성, 이식성

* `설계`는 '어떠한 문제를 효율적으로 해결하는 구조를 만드는 것'을 의미한다.

    그렇다면 **소프트웨어에서 `설계`** 란, '**어떤 소프트웨어의 품질 특성을 향상**시키기 위한 구조를 만드는 것'이라고 말할 수 있다.

* 이 책은 소프트웨어 개발에서 나타날 수 있는 악마를 퇴치하는 설계 방법을 설명했다.

    이러한 악마의 설징과 가장 관련 있는 품질 특성은 `유지 보수성`이다.

    `유지 보수성`은 **시스템이 정상 운용되도록 유지 보수하기가 얼마나 쉬운가를 나타내는 정도**를 말한다.

    유지 보수성 중에서도 특히 **변경 용이성**을 목적으로 하는 설계 방법을 다루어 온 것이다.

### 개발 생산성을 저하되는 요인

* 변경 용이성 설계를 하지 않으면, 개발 생산성이 저하되는데, 저하 요인으로는 크게 2가지가 있다.

    * 요인 1: 버그가 발생하기 쉬운 구조

    * 요인 2: 가독성이 낮은 구조

* 제대로 설계하지 않으면, 로직 변경과 디버그에 많은 시간을 소비하게 된다.

### 소프트웨어와 엔지니어의 성장 가능성

* **소프트웨어의 성장 가능성을 높이는 것**이 바로 이 책의 핵심 주제이자 의의.

* '엔지니어'에게 '자산'이란 **기술력**이라고 생각함.

* `레커시 코드`는 프로젝트 발전과, 고품질 설계 경험을 막는다. 또한 시간을 낭비하게 만든다. 

    이러한 `레거시 코드`는 기술 향상을 막고, 엔지니어에게 정말 중요한 자산이라고 할 수 있는 **기술력**의 축적을 막는다.

### 문제 해결

* 문제는 항상 이상과 현실의 차이 때문에 발생한다.

    * 따라서 **이상이 무엇인지 알고 있다면**, 현실과 비교하며 차근차근 문제를 해결할 수 있다.

    * 이와 같이 설계에서도 이상적인 설계와 현재 설계를 비교하면, **기술 부채를 인식**할 수 있다.

### 코드의 좋고 나쁨을 판단하는 지표

* 루비의 코드 분석 라이브러리 `RuboCop`에 따르면, **줄 수 상한**이 `메서드`를 기준으로 10줄 이내이고, `클래스`를 기준으로는 100줄 이내로 판단한다.

    * 줄 수가 너무 많으면, '메서드와 클래스 분할'을 검토하자.

    * 분할했으면, 분할한 클래스 하나하나가 **일관되고 정상적인 동작을 하는 구조**를 가져야 한다.

    * "클래스를 분할하면 읽기 어려워질까?" -> 클래스를 분할한 이후에, 클래스 하나하나가 정상적으로 동작하도록 설계하게 되면, 신뢰성이 높아져서 내부 로직에 대해 신경이 줄어들게 된다. -> 읽기가 더 쉬워지게 된다. 

* `순환 복잡도`는 코드의 구조적인 복잡함을 나타내는 지표이다.

    * 조건 분기, 반복 처리, 중첩이 많아지면 복잡도가 커진다.

    * 순환 복잡도가 10이하 -> 굉장히 좋은 구조이고 버그가 발생할 확률은 25%이하이다.

* `응집도`는 모듈 내부에서 데이터와 로직이 관련되어 있는 정도를 나타내는 지표이다.

    * 클래스로 해석하면, 클래스 내부에서 **데이터와 로직의 관계가 얼마나 강한지 나타내는 지표**이다.

    * **응집도가 높을수록 변경 용이성이 높고 좋은 구조**이다.

* `결합도`는 모듈 간의 의존도를 나타내는 지표이다.

    * 클래스로 해석하면, 결합도는 '어떤 클래스가 호출하는 다른 클래스의 수'라고 볼 수 있다. (A라는 클래스가 B, C, D를 호출하고 있다라고 하면, 3개를 의존하게 된다)

    * 의존하고 있는 클래스가 많으면 많을수록, 즉 **결합도가 높을수록 더 넓은 범위를 고려해야 하므로, 유지 보수와 사양 변경이 어렵다.**

    * 결합도가 너무 높으면 `단일 책임 원칙`을 위배하므로, 의존을 더 줄일 수 없는지, 클래스를 더 적게 분할할 수 없는지 검토해봐야 한다.

## 16장. 설계를 방해하는 개발 프로세스와의 싸움

### 커뮤니케이션

* 커뮤니케이션이 부족하면 버그가 많아지는 경향이 있다.

* `콘웨이 법칙`이란 '시스템의 구조는 그것을 설계하는 조직의 구조를 닮아 간다'는 접근 방법을 말한다.

    예를 들어 개발 부문이 3개의 팀으로 구분되어 있다면 모듈이 수도 팀의 수와 동일하게 3개로 구성되는 시스템이 만들어진다는 것이다.

    즉, 시스템의 구조가 릴리스 단위, 즉 팀 단위의 구조처럼 구성된다.

    반대로, `역콘웨이 법칙`은 '소프트웨어의 구조를 먼저 설계하고, 이후 소프트웨어의 구조에 맞게 조직을 편성한다'는 접근 방법을 말한다.

* 팀원 간 관계 개선에는 `심리적 안정성`이 중요하다.

    `심리적 안정성`이란 어떤 발언을 했을 때, '부끄럽거나 거절당하지 않을 것이라는 심리 상태', '안심하고 자유롭게 발언 또는 행동할 수 있는 상태' 등으로 정의한다.

     성공적인 팀을 구축할 때 매우 중요한 개념이라고 알려져 있다.

### 설계

* '빨리 끝내고 싶다'는 심리로 인해 설계 품질을 저하되게 만드는데, 이는 바람직하지 않다.

    품질에 신경쓰지 않으면, 시간이 지날수록 구현 속도가 느려지게 된다. 나쁜 코드로 인한 구현 때문에 코드 수정이 다른 곳에 영향을 미치기 때문이다.

* `TDD`를 기반으로 클래스 설계와 구현 피드백 사이클을 돌리면서 설계 품질을 향상 시킨다.

* 한 번에 완벽하게 설계하지 않고 사이클을 돌려가며 완성한다. (한 번에 완벽하게 설계하려는 욕심 버리기!)

    피드백 사이클을 돌며 개발 할 때는 개발 방식에 대해 처음부터 확실하게 **합의**하고 시작하는 것이 좋다.

* **너무 빠른 최적화**(premature optimization)는 지양하자. - 병목이 어디인지 모른 채 성능이 빠른 코드를 작성하려고 하는 것

    대부분의 경우에서 클래스 쪼개기가 성능에 미치는 영향이 전혀 없거나 거의 없다.

* 다수결로 설계 규칙을 만들지 말자.

    `설계 규칙`을 정할 때 시니어 엔지니어처럼 **`설계 역량이 뛰어난 팀원`이 중심이 되어 규칙을 만드는 것이 좋다.**

    다수결로 코드와 설계를 결정하려고 하면, 아무래도 수준이 낮은 쪽에 맞춰서 하향평준화되기 쉽기 때문이다.

    각각의 설계 규칙에는 **이유와 의도**를 함께 적는 것이 좋다. -> 아무런 의미를 갖지 않는 상황을 막기 때문

    팀의 설계 역량이 성숙하지 않으면, 개인에게 맡기지 말고, `설계를 어느 정도 아는 팀원`이 **설계 리뷰와 코드 리뷰**를 하도록 해서, 설계 품질을 관리할 수 있게 한다.

    팀 구성원의 설계 역량이 어느 정도 성숙해지면, 다시 한번 설계 규칙에 대해 논의해보는 것도 좋다.


### 구현

* **관점과 접근 방법**을 바꾸면 코드를 구현하는 방법이 달라질 수 있다.

* 기존의 코드를 믿지 말고, 냉정하게 파악한다.

    레거시 코드를 박멸하려면, 기존의 코드를 맹신하지 않는 마음가짐이 중요하다.

    **정체를 파악하는 행위** - '이 코드는 무엇을 해결하고 싶은 코드일까?', '이 코드가 달성하려는 목적이 무엇일까?' 등을 분석하고, 이상적인 설계를 처음부터 다시 생각해보는 작업

* 코딩 규칙(코드 컨벤션 규칙), 명명규칙 사용하기

    `명명 규칙`이란 변수 이름, 클래스 이름, 메서드 이름을 정하는 규칙이다.

### 리뷰

* 코드 리뷰 구조화하기

    풀 리퀘스트한 코드는 '코드의 히스토리와 경위를 알고 있는 사람' 또는 '설계를 자세하게 알고 있는 사람'이 리뷰하는 것이 좋다.

* 코드를 설계 시점에 리뷰하기

    로직이 기능 요건을 만족하는지, 결함이 존재하는지 보다는 **설계적 타당성**을 중심으로 리뷰해야 한다.

* 존중과 예의

    기술적 올바름과 유용성보다는 함께 일하는 동료를 존중하는 것이 먼저이다.

    존중과 예의를 갖추고 지적하는 것이 코드 품질을 높이는 가장 빠른 길이다.

* 정기적으로 개선 작업 진행하기

    좋지 않은 코드에 대처하는 일은 작업 관리 도구에 `개선 작업`으로 추가해둔다.

    작업 관리에는 깃허브의 `이슈`(Issue)를 활용한다.

    정기적으로 이러한 작업을 모아 개선 작업을 진행해서 확실하게 대처할 수 있게 만드는 것이 좋다.

### 팀의 설계 능력 높이기

* 리더와 매니저에게 설계의 중요성과 비용 대비 효과 설명하기

    조직 차원에서 설계 품질을 향상시키려면, 리더와 매니저에게 설계의 필요성을 공유해야 한다.

    매니저에게는 **비용 대비 효과**를 중심으로 이야기를 한다.

    또한 매니저에게 설명할 때, **동료와 함께하는 것**이 바람직하다. 동료들과 했던 설계 활동과 그 실적을 함께 설명하면 설득력이 더욱 높아진다.

* 설계 책임자 세우기 - 변경 용이성 품질 향상을 위해 다음과 같은 내용을 추진한다.

    * 설계 품질과 관련된 규칙이나 개발 프로세스 수립

    * 규칙을 반복적으로 알리고 교육

    * 리더와 매니저에게 효과 공유

    * 품질 시각화

    * 설계 품질 유지

## Reference

* [내 코드가 그렇게 이상한가요?: 좋은코드 나쁜코드로 배우는 설계 입문](https://product.kyobobook.co.kr/detail/S000202521361)
